PlayerID{{
        public int compareTo(PlayerID pid)
        { return ((Integer)id).compareTo(pid.id); }
}}

Var{{
        public int compareTo(Var v)
        { return id.compareTo(v.id); }
}}

Solution{{ }}
Challenge{{ }}
         
OfferedChallenge{{
    public AcceptedChallenge accept(PlayerID challengee){
        return new AcceptedChallenge(challengee, this.key, this.challenger,
                this.pred, this.price);
    }
    
    public OfferedChallenge reoffer(PlayerID challenger, double newPrice){
        return new OfferedChallenge(key, challenger, pred, newPrice);
    }
    
 }}
AcceptedChallenge{{
    public ProvidedChallenge provide(Problem problem){
        return new ProvidedChallenge(challengee, problem, key, challenger,
                pred, price);
    }
 }}
ProvidedChallenge{{ }}
SolvedChallenge{{ }}


Transaction{{
   public int getChallengeid(){ throw new RuntimeException("No Challenge ID"); }
   public abstract void install(int playerId, GameI game, boolean isOverTime);
}}

OfferTrans{{
   public void install(int playerId, GameI game, boolean isOverTime){
       if(!isOverTime){
           game.installTransaction(playerId, this);
       }
   }
}}
AcceptTrans{{ 
   public void install(int playerId, GameI game, boolean isOverTime){
           if(!isOverTime){
            game.installTransaction(playerId, this);
        }
    }
}}
ProvideTrans{{ 
   public void install(int playerId, GameI game, boolean isOverTime){
        game.installTransaction(playerId, this);
    }
}}
SolveTrans{{ 
   public void install(int playerId, GameI game, boolean isOverTime){
        game.installTransaction(playerId, this);
    }
}}
ReofferTrans{{
   public void install(int playerId, GameI game, boolean isOverTime){
           if(!isOverTime){
            game.installTransaction(playerId, this);
        }
    }
}}

PlayerTrans{{

    public void applyTransactions(GameI game, boolean isOverTime){
        final int playerID = getId().getId();
        for (Transaction trans : getTs()) {
            trans.install(playerID, game, isOverTime);
        }
    }

    public List<OfferTrans> getOfferTrans(){
        return (List)ts.filter(new List.Pred<Transaction>(){
            public boolean huh(Transaction t){
                return (t instanceof OfferTrans);
            }
        });
    }

    public List<AcceptTrans> getAcceptTrans(){
        return (List)ts.filter(new List.Pred<Transaction>(){
            public boolean huh(Transaction t){
                return (t instanceof AcceptTrans);
            }
        });
    }

    public List<ProvideTrans> getProvidedTrans(){
        return (List)ts.filter(new List.Pred<Transaction>(){
            public boolean huh(Transaction t){
                return (t instanceof ProvideTrans);
            }
        });
    }

    public List<SolveTrans> getSolvedTrans(){
        return (List)ts.filter(new List.Pred<Transaction>(){
            public boolean huh(Transaction t){
                return (t instanceof SolveTrans);
            }
        });
    }
    
    public List<ReofferTrans> getReofferTrans(){
        return (List)ts.filter(new List.Pred<Transaction>(){
            public boolean huh(Transaction t){
                return (t instanceof ReofferTrans);
            }
        });
    }

 }}


PlayerContext{{
    public boolean isOverTime(){
      return currentRound > config.getNumrounds();
    }
    /**  */
    public List<OfferedChallenge> getAllOffered(){ return ourOffered.append(theirOffered); }
    
    public void isLegal(PlayerTrans trans){
        boolean overTime = config.isOverTime(currentRound);
        if (!overTime) {
            acceptOrReoffer(trans);//Rule 2
        }
        offerNewChallenges(trans); //Rule 3
        provideAllAccepted(trans);//Rule 4
        provideCorrectProblems(trans);//Rule 4
        solveFromProvided(trans);//Rule 4
        checkReoffersDecrement(trans);//Rule 5
        acceptFromOthers(trans);//Rule 6*
        acceptAffordableChallenges(trans);//Rule 7
        reofferFromOthers(trans);//Rule 7
        challengerAffordsSolution(trans);//Rule 7
        currentPlayerResponded(trans);
    }

    private void reofferFromOthers(PlayerTrans trans){
        boolean allOffered = getTheirOffered().containsAllG(trans.getReofferTrans(),
                Config.<OfferedChallenge, ReofferTrans> getComp());
        if (!allOffered) {
            throw new RuntimeException("Reoffered a challenge not offered by others");
        }

    }

    private void checkReoffersDecrement(PlayerTrans trans){
        for (ReofferTrans rt : trans.getReofferTrans()) {
            double offeredPrice = findChallenge(getTheirOffered(), rt.getChallengeid()).getPrice();
            if (rt.getPrice() >= offeredPrice || rt.getPrice() > 0
                    && Util.lessThan(offeredPrice - rt.getPrice(), config.getMindecr())) {
                throw new RuntimeException("Reoffer by less than mindec (" + (offeredPrice - rt.getPrice()) + ")");
            }
        }
    }

    /*
     * TODO: This method doesn't make sense... The current player should be
     * *paid* when solving a challenge. The player who Offered is the one who
     * gets charged. Again we should check for negative balabces at the end of
     * the round, all in one place.
     */
    private void challengerAffordsSolution(PlayerTrans trans){
        double balance = getBalance();
        for (SolveTrans solTrans : trans.getSolvedTrans()) {
            Solution sol = solTrans.getSol();
            int challengeID = solTrans.getChallengeid();
            for (ProvidedChallenge challenge : getProvided()) {
                if (challenge.getKey() == challengeID) {
                    double quality = config.getObjective().value(challenge.getInstance(), sol);
                    double payoff = config.getObjective().calculatePayoff(quality,
                            config.getObjective().getDefaultQuality(challenge.getInstance()), challenge.getPrice(),
                            config.getProfitFactor());
                    balance -= payoff;
                    if (balance < 0) {
                        throw new RuntimeException("Challenger cannot affort solution");
                    }
                }
            }
        }
    }

    private void solveFromProvided(PlayerTrans trans){
        boolean allSolved = getProvided().sameG(trans.getSolvedTrans(),
                Config.<ProvidedChallenge, SolveTrans> getComp());
        if (!allSolved) {
            throw new RuntimeException("Solved and provided challenges don't match");
        }
    }

    private void provideAllAccepted(PlayerTrans trans){
        boolean same = getAccepted()
                .sameG(trans.getProvidedTrans(), Config.<AcceptedChallenge, ProvideTrans> getComp());
        if (!same) {
            throw new RuntimeException("Didn't provide all problems");
        }
    }

    private void provideCorrectProblems(PlayerTrans trans){
        for (ProvideTrans proTrans : trans.getProvidedTrans()) {
            Problem problem = proTrans.getInst();
            int challengeId = proTrans.getChallengeid();
            for (AcceptedChallenge challenge : getAccepted()) {
                if (challenge.getKey() == challengeId) {
                    if (!config.getPredicate().valid(problem, challenge.getPred())) {
                        throw new RuntimeException("Provided problem does not conform to challenge predicate");
                    }
                }
            }
        }
    }

    private void acceptOrReoffer(PlayerTrans trans){
        if (getTheirOffered().length() > 0) {
            int size = trans.getAcceptTrans().length() + trans.getReofferTrans().length();
            /* TODO: Should check these individually based on the Configuration */
            if (size <= 0) {
                throw new RuntimeException("Didn't buy nor reoffer");
            }
        }
    }

    private void acceptAffordableChallenges(final PlayerTrans trans){
        double sum = trans.getAcceptTrans().fold(new edu.neu.ccs.demeterf.lib.List.Fold<AcceptTrans, Double>() {

            @Override
            public Double fold(AcceptTrans trans, Double sum){
                int challengeID = trans.getChallengeid();

                /*
                 * TODO: Can we filter TheirOffered then fold, instead of
                 * running this loop everytime?
                 */
                for (Challenge challenge : getTheirOffered()) {
                    if (challenge.getKey() == challengeID) {
                        return sum + challenge.getPrice();
                    }
                }
                return sum;// will be caught by another check.
            }
        }, 0.0);
        /* TODO: I (BC) Think this is/was broken... */
        // if (sum > getId().getId()) {
        /* TODO: Here's what I think was meant */
        if (sum > getBalance()) {
            throw new RuntimeException("Insufficient funds");
        }
        /*
         * TODO: I think we should check for a positive Balance after the entire
         * round has been processed... not just one turn. They might be able to
         * make money on other players (solve) and also might lose money
         * (provide) so there are other ways to have insufficient funds. Better
         * to check for negative balance all in one place.
         */
    }

    private void acceptFromOthers(PlayerTrans trans){
        boolean allOffered = getTheirOffered().containsAllG(trans.getAcceptTrans(),
                Config.<OfferedChallenge, AcceptTrans> getComp());
        if (!allOffered) {
            throw new RuntimeException("Accepted a challenge not offered by others");
        }

    }

    /** Offer challenges not in store */
    private void offerNewChallenges(PlayerTrans trans){
        boolean notFresh = getAllOffered().containsAnyG(trans.getOfferTrans(),
                new edu.neu.ccs.demeterf.lib.List.GComp<OfferedChallenge, OfferTrans>() {

                    @Override
                    public boolean comp(OfferedChallenge ch, OfferTrans trans){
                        return ch.getPred().equals(trans.getPred());
                    }
                });
        if (notFresh) {
            throw new RuntimeException("Challenge already in store");
        }
    }

    /** Check that the correct player has responded */
    private void currentPlayerResponded(PlayerTrans trans){
        if (!getId().equals(trans.getId())) {
            throw new RuntimeException("Incorrect Player Responded");
        }
    }

    /** Find the given Challenge ID in the given List */
    static <CH extends Challenge> CH findChallenge(edu.neu.ccs.demeterf.lib.List<CH> lst, final int chID){
        return lst.find(new edu.neu.ccs.demeterf.lib.List.Pred<CH>() {

            @Override
            public boolean huh(CH ch){
                return ch.getKey() == chID;
            }
        });
    }
    
}}


/**
 * 
 * Holds the game configuration parameters
 * Acts as a factory for player and challenge ids
 *
 */
Config{{
    private final int START_PLAYER_ID = 100;
    private final int START_CHALLENGE_ID = 500;
    
    private int currentChallengeID = START_CHALLENGE_ID;
    private int currentPlayerID = START_PLAYER_ID;
    
    public int createPlayerID(){
        return currentPlayerID++;
    }
    
    public int createChallengeID(){
        return currentChallengeID++;
    }
    
    public boolean isOverTime(int round){
      return round > getNumrounds();
    }
    
    /** Get a general comparator that can compare Challenges to Transactions */
    static <CH extends Challenge, TR extends Transaction> edu.neu.ccs.demeterf.lib.List.GComp<CH, TR> getComp(){
        return new edu.neu.ccs.demeterf.lib.List.GComp<CH, TR>() {

            @Override
            public boolean comp(CH ch, TR t){
                return t.getChallengeid() == ch.getKey();
            }
        };
    }
    
}}


GameI{{
    /** Handle an offer challenge transaction */
    void installTransaction(int challengerID, OfferTrans ot);

    /** Handle an accept challenge transaction */
    void installTransaction(int challengeeID, AcceptTrans at);

    /** Handle Provide Transactions */
    void installTransaction(int challengerID, ProvideTrans pt);
 
    /** Handle Solve Transactions */
    void installTransaction(int challengeeID, SolveTrans st);

    /** Handle Reoffer Transactions */
    void installTransaction(int newChallenger, ReofferTrans rt);
}}