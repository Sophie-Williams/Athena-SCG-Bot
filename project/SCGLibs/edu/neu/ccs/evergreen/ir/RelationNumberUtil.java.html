<html><head><title>RelationNumberUtil.java</title></head>
<!-- HTMLized with the Beditor
     *c* Bryan Chadwick, 2003 -->
<style type='text/css'><!--
   .def{ color: #000000; }
   .grade{
      border: solid #FF0000 1px;
      background-color: #FFFF60;
   }
   .gcom{ font-weight: bold; background-color: #FFC0C0; }
   .com{ font-style: italic; color: #880000; }
   .keyw{ font-weight: bold; color: #000088; }
   .num{ color: #00AA00; }
   .func{ color: #BB7733; }
   .str{ color: #CC00AB; }
   .prim{ color: #0000FF; }
--></style>
<body><pre><span class="def">
</span><span class="com">/**
 * 
 */</span><span class="def">
</span><span class="keyw">package</span><span class="def"> edu.neu.ccs.evergreen.ir;

</span><span class="com">/**
 * @author mohsen
 * The RelationNumberUtil class provides a set of methods for synthesizing relation numbers.
 * Note that the created relation numbers can be manipulated using bitwise operations
 * provided that they share the same variables and same variable ordering
 * Variable positions are 0 based
 * for example:
 * int x = 0;
 * int y = 1;
 * int z = 2;
 * int w = 3;
 * int r_or_xy = RelationNumberUtil.or(4,x,y)
 * int r_or_zw =  RelationNumberUtil.or(4,z,w)
 * int r_or_xyzw = r_or_xy|r_or_zw
 * 
 * The relation provides:
 * 		 or(arbitrary number of variables,
 *       and(arbitrary number of variables,
 *       imply (two vars)
 *       equiv (two vars)
 *       xor (two vars)
 *       
 * Use RelationCore.getMagicNumber(rank,x,1) to get a relation representing x
 * Use RelationCore.getMagicNumber(rank,x,0) to get a relation representing !x
 * 
 */</span><span class="def">

</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">class</span><span class="def"> RelationNumberUtil {

	</span><span class="com">/**
	 * Given a set of variable positions, return a relation that is the or of these variables
	 * @param rank the rank of the created relation
	 * @param variablePositions an arbitrary number of variable positions
	 * @return a relation number that represents the oring of the variables at the given positions
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">or</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">int</span><span class="def"> relationNumber=</span><span class="num">0</span><span class="def">;
		</span><span class="keyw">for</span><span class="def">(</span><span class="keyw">int</span><span class="def"> variablePosition: variablePositions){
			</span><span class="com">// Note that the getMagicNumber will check for the validity of the given variablePosition</span><span class="def">
			relationNumber|= RelationCore.</span><span class="func">getMagicNumber</span><span class="def">(rank, variablePosition, </span><span class="num">1</span><span class="def">);
		}
		</span><span class="keyw">return</span><span class="def"> relationNumber;
	}

	</span><span class="com">/**
	 * Given a set of variable positions, return a relation that is the anding of these variables
	 * @param rank the rank of the created relation
	 * @param variablePositions an arbitrary number of variable positions
	 * @return a relation number that represents the anding of the variables at the given positions
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">and</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">int</span><span class="def"> relationNumber = RelationCore.</span><span class="func">getMask</span><span class="def">(rank);
		</span><span class="keyw">for</span><span class="def">(</span><span class="keyw">int</span><span class="def"> variablePosition: variablePositions){
			</span><span class="com">// Note that the getMagicNumber will check for the validity of the given variablePosition</span><span class="def">
			relationNumber&= RelationCore.</span><span class="func">getMagicNumber</span><span class="def">(rank, variablePosition, </span><span class="num">1</span><span class="def">);
		}
		</span><span class="keyw">return</span><span class="def"> relationNumber;
	}

	</span><span class="com">/**
	 * nMaps a number of variables in a certain relation
	 * @param relationNumber  
	 * @param rank the rank of the created relation
	 * @param variablePositions an arbitrary number of variable positions
	 * @return a relation number that represents the given relation with the given set of variables renamed
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">nMap</span><span class="def">(</span><span class="keyw">int</span><span class="def"> relationNumber,</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">for</span><span class="def">(</span><span class="keyw">int</span><span class="def"> variablePosition: variablePositions){
			</span><span class="com">// Note that the getMagicNumber will check for the validity of the given variablePosition</span><span class="def">
			relationNumber = RelationCore.</span><span class="func">nMap</span><span class="def">(relationNumber, rank, variablePosition);
			}
		</span><span class="keyw">return</span><span class="def"> relationNumber;
	}
	
	</span><span class="com">/**
	 * Given two variables x,y returns a relation that represents x==&gt;y
	 * @param rank the rank of the created relation
	 * @param variablePositions two variable positions
	 * @return a relation number that represents the x=&gt;y where x,y are the given two variable positions
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">imply</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">if</span><span class="def">(variablePositions.length&gt;</span><span class="num">2</span><span class="def">) 
			</span><span class="keyw">throw</span><span class="def"> </span><span class="keyw">new</span><span class="def"> </span><span class="func">IllegalArgumentException</span><span class="def">(</span><span class="str">"imply supports up to 2 variables. Passed "</span><span class="def">+variablePositions.length);
		
		</span><span class="keyw">int</span><span class="def"> relationNumber = </span><span class="func">or</span><span class="def">(rank, variablePositions[</span><span class="num">0</span><span class="def">],variablePositions[</span><span class="num">1</span><span class="def">]); 
		</span><span class="keyw">return</span><span class="def"> </span><span class="func">nMap</span><span class="def">(relationNumber, rank, variablePositions[</span><span class="num">0</span><span class="def">]);
	}
	
	</span><span class="com">/**
	 * Given two variables x,y returns a relation that represents x=y
	 * @param rank the rank of the created relation
	 * @param variablePositions two variable positions
	 * @return a relation number that represents the x=y where x,y are the given two variable positions
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">equiv</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">if</span><span class="def">(variablePositions.length&gt;</span><span class="num">2</span><span class="def">) 
			</span><span class="keyw">throw</span><span class="def"> </span><span class="keyw">new</span><span class="def"> </span><span class="func">IllegalArgumentException</span><span class="def">(</span><span class="str">"equiv supports up to 2 variables. Passed "</span><span class="def">+variablePositions.length);
		
		</span><span class="keyw">int</span><span class="def"> bothNeg = </span><span class="func">and</span><span class="def">(rank,variablePositions[</span><span class="num">0</span><span class="def">],variablePositions[</span><span class="num">1</span><span class="def">]);
		bothNeg = </span><span class="func">nMap</span><span class="def">(bothNeg, rank, variablePositions);
		</span><span class="keyw">int</span><span class="def"> bothPos = </span><span class="func">and</span><span class="def">(rank,variablePositions[</span><span class="num">0</span><span class="def">],variablePositions[</span><span class="num">1</span><span class="def">]);
		</span><span class="keyw">return</span><span class="def"> bothNeg|bothPos;
	}
	</span><span class="com">/**
	 * Given two variables x,y returns a relation that represents xor(x,y)
	 * @param rank the rank of the created relation
	 * @param variablePositions two variable positions
	 * @return a relation number that represents the xor(x,y) where x,y are the given two variable positions
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">xor</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank, </span><span class="keyw">int</span><span class="def"> ... variablePositions){
		</span><span class="keyw">if</span><span class="def">(variablePositions.length&gt;</span><span class="num">2</span><span class="def">) 
			</span><span class="keyw">throw</span><span class="def"> </span><span class="keyw">new</span><span class="def"> </span><span class="func">IllegalArgumentException</span><span class="def">(</span><span class="str">"xor supports up to 2 variables. Passed "</span><span class="def">+variablePositions.length);
		
		</span><span class="keyw">int</span><span class="def"> posNeg = </span><span class="func">and</span><span class="def">(rank,variablePositions[</span><span class="num">0</span><span class="def">],variablePositions[</span><span class="num">1</span><span class="def">]);
		posNeg = </span><span class="func">nMap</span><span class="def">(posNeg, rank, variablePositions[</span><span class="num">1</span><span class="def">]);
		</span><span class="keyw">int</span><span class="def"> negPos = </span><span class="func">and</span><span class="def">(rank,variablePositions[</span><span class="num">0</span><span class="def">],variablePositions[</span><span class="num">1</span><span class="def">]);
		negPos = </span><span class="func">nMap</span><span class="def">(negPos, rank, variablePositions[</span><span class="num">0</span><span class="def">]);
		</span><span class="keyw">return</span><span class="def"> posNeg|negPos;
	}

	</span><span class="com">/**
	 * for 1in3 use xTrueVars(3,1)
	 * @param rank
	 * @param numberOfTrueVars
	 * @return an integer representing the relation number which is true only when the given number of vars is true
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">int</span><span class="def"> </span><span class="func">xTrueVars</span><span class="def">(</span><span class="keyw">int</span><span class="def"> rank,</span><span class="keyw">int</span><span class="def"> numberOfTrueVars){
		</span><span class="keyw">int</span><span class="def"> relationNumber = </span><span class="num">0</span><span class="def">;
		</span><span class="keyw">for</span><span class="def"> (</span><span class="keyw">int</span><span class="def"> i = </span><span class="num">0</span><span class="def">; i &lt; (</span><span class="num">1</span><span class="def">&lt;&lt;rank); i++) {
			</span><span class="com">//RelationCore.ones(i, 3) a truth table row can have up to 5 columns</span><span class="def">
			</span><span class="com">//RelationCore.ones(i, 3) will count ones up to the 8th column</span><span class="def">
			</span><span class="keyw">if</span><span class="def">(RelationCore.</span><span class="func">ones</span><span class="def">(i, </span><span class="num">3</span><span class="def">)==numberOfTrueVars) 
				relationNumber|=(</span><span class="num">1</span><span class="def">&lt;&lt;i);
		}
		</span><span class="keyw">return</span><span class="def"> relationNumber;
	}
	</span><span class="com">/**
	 * @param args
	 */</span><span class="def">
	</span><span class="keyw">public</span><span class="def"> </span><span class="keyw">static</span><span class="def"> </span><span class="keyw">void</span><span class="def"> </span><span class="func">main</span><span class="def">(</span><span class="prim">String</span><span class="def">[] args) {
		</span><span class="com">// TODO Auto-generated method stub</span><span class="def">
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="str">""</span><span class="def">+(-</span><span class="num">3</span><span class="def">&</span><span class="num">0xFFFFFFFF</span><span class="def">));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="str">""</span><span class="def">+(-</span><span class="num">3</span><span class="def">&</span><span class="num">0xFFFFFFFF</span><span class="def">));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">xTrueVars</span><span class="def">(</span><span class="num">3</span><span class="def">, </span><span class="num">0</span><span class="def">));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">xTrueVars</span><span class="def">(</span><span class="num">3</span><span class="def">, </span><span class="num">1</span><span class="def">));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">xTrueVars</span><span class="def">(</span><span class="num">3</span><span class="def">, </span><span class="num">2</span><span class="def">));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">xTrueVars</span><span class="def">(</span><span class="num">3</span><span class="def">, </span><span class="num">3</span><span class="def">));
		</span><span class="keyw">int</span><span class="def">[] all = {</span><span class="num">0</span><span class="def">,</span><span class="num">1</span><span class="def">,</span><span class="num">2</span><span class="def">};
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">nMap</span><span class="def">(</span><span class="func">xTrueVars</span><span class="def">(</span><span class="num">3</span><span class="def">, </span><span class="num">1</span><span class="def">),</span><span class="num">3</span><span class="def">,all));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">and</span><span class="def">(</span><span class="num">3</span><span class="def">,all));
		System.out.</span><span class="func">println</span><span class="def">(</span><span class="func">or</span><span class="def">(</span><span class="num">3</span><span class="def">,all));
	}

}
</span></pre></body></html>