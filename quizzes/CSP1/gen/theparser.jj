
// ** This class was generated with DemFGen (vers:09/12/2009)

options{ STATIC = false;  }
PARSER_BEGIN(TheParser)
package gen;

import edu.neu.ccs.demeterf.lib.*;
import edu.neu.ccs.demeterf.*;
import edu.neu.ccs.demeterf.control.Fields;
import edu.neu.ccs.demeterf.lib.ident;
import edu.neu.ccs.demeterf.lib.verbatim;

  class TheParser{

   public static String unescape(String str){
      String retval = "";
      int index = 0;
      char ch, ch1;
      int ordinal = 0;
      while (index < str.length()) {
         if(str.charAt(index) != '\\') { retval += str.charAt(index++); continue; }
         ch = str.charAt(++index);
         if(ch == 'b') { retval += '\b'; index++; continue; }
         if(ch == 't') { retval += '\t'; index++; continue; }
         if(ch == 'n') { retval += '\n'; index++; continue; }
         if(ch == 'f') { retval += '\f'; index++; continue; }
         if(ch == 'r') { retval += '\r'; index++; continue; }
         if(ch == '"') { retval += '\"'; index++; continue; }
         if(ch == '\'') { retval += '\''; index++; continue; }
         if(ch == '\\') { retval += '\\'; index++; continue; }
         if(ch >= '0' && ch <= '7'){
            ordinal = ((int)ch) - ((int)'0'); index++;
            ch1 = str.charAt(index);
            if(ch1 >= '0' && ch1 <= '7'){
               ordinal = ordinal*8 + ((int)ch1) - ((int)'0'); index++;
               ch1 = str.charAt(index);
               if(ch <= '3' && ch1 >= '0' && ch1 <= '7'){
                  ordinal = ordinal*8 + ((int)ch1) - ((int)'0'); index++;
               }
            }
            retval += (char)ordinal;
            continue;
         }
         if(ch == 'u'){
            ordinal = 0;
            for(int i = 0; i < 4; i++){
               index++; ch = str.charAt(index);
               ordinal = ordinal*16+hexval(ch);
            }
            index++;
            retval += (char)ordinal;
            continue;
         }
      }
      return retval;
   }
   static int hexval(char c){
      int r = "0123456789ABCDEF".indexOf(Character.toUpperCase(c));
      if(r >= 0)return r;
      throw new RuntimeException(" ** Bad Escaped Character");
   }
  }
PARSER_END(TheParser)

byte parse_byte():{ int i; }{
    i = parse_int() { return (byte)i; }
}
Byte parse_Byte():{ byte b; }{
    b = parse_byte() { return b; }
}
short parse_short():{ int i; }{
    i = parse_int() { return (short)i; }
}
Short parse_Short():{ short s; }{
    s = parse_short() { return s; }
}
int parse_int():{ Token t; }{
    t = <INT>
    { if(t.image.length() > 1 && Character.toLowerCase(t.image.charAt(1)) == 'x')
          return Integer.parseInt(t.image.substring(2), 16);
      return Integer.parseInt(t.image); }
}
Integer parse_Integer():{ int i; }{
    i = parse_int() { return i; }
}
long parse_long():{ Token t; }{
    t = <INT>
    { if(t.image.length() > 1 && Character.toLowerCase(t.image.charAt(1)) == 'x')
          return Long.parseLong(t.image.substring(2), 16);
    return Long.parseLong(t.image); }
}
Long parse_Long():{ long l; }{
    l = parse_long() { return l; }
}
double parse_double():{ Token t; }{
    t = <DOUBLE>
    { return Double.parseDouble(t.image); }
}
Double parse_Double():{ double d; }{
    d = parse_double() { return d; }
}
float parse_float():{ Token t; }{
    t = <DOUBLE>
    { return Float.parseFloat(t.image); }
}
Float parse_Float():{ float f; }{
    f = parse_float() { return f; }
}
String parse_String():{ Token t; }{
    t = <STRING>
    { return unescape(t.image.substring(1,t.image.length()-1)); }
}
boolean parse_boolean():{ Token t; }{
    t = <TRUE> { return true; } |
    t = <FALSE> { return false; }
}
Boolean parse_Boolean():{ boolean b; }{
    b = parse_boolean() { return b; }
}
char parse_char():{ Token t; }{
    t = <CHAR>
    { return unescape(t.image.substring(1,t.image.length()-1)).charAt(0); }
}
Character parse_Character():{ char c; }{
    c = parse_char() { return c; }
}
ident parse_ident():{ Token t; }{
    t = <IDENT>
    { return new ident(t.image); }
}
verbatim parse_verbatim():{ Token t; }{
    t = <TEXT>
    { return new verbatim(t.image.substring(2,t.image.length()-2)); }
}




public SimpleProblems parse_SimpleProblems():{
     List<Problem> constraints;
}{
    constraints = parse_List$Problem$()
    <EOF>
    { return new SimpleProblems(constraints); }
}

public Problem parse_Problem():{
     List<Constraint> constraints;
}{
    "problem"
    "("
    constraints = parse_List$Constraint$()
    ")"
    { return new Problem(constraints); }
}

public Constraint parse_Constraint():{
     Relation r;
     List<Variable> vars;
}{
    "rel:"
    r = parse_Relation()
    "vars:"
    vars = parse_List$Variable$()
    { return new Constraint(r,vars); }
}

public Relation parse_Relation():{
     Length length;
     Positive pos;
}{
    "or"
    length = parse_Length()
    pos = parse_Positive()
    { return new Relation(length,pos); }
}

public Length parse_Length():{
     int v;
}{
    v = parse_int()
    { return new Length(v); }
}

public Positive parse_Positive():{
     int v;
}{
    v = parse_int()
    { return new Positive(v); }
}

public Variable parse_Variable():{
     ident v;
}{
    v = parse_ident()
    { return new Variable(v); }
}

public List<Variable> parse_List$Variable$():{
    List<Variable> sup = null;
}{
(   sup = parse_Cons$Variable$() { return sup; } | 
    sup = parse_Empty$Variable$() { return sup; } )
}
public Empty<Variable> parse_Empty$Variable$():{
}{

    { return new Empty<Variable>(); }
}
public Cons<Variable> parse_Cons$Variable$():{
     Variable first;
     List<Variable> rest;
}{
    first = parse_Variable()
    rest = parse_List$Variable$()
    { return new Cons<Variable>(first,rest); }
}
public List<Constraint> parse_List$Constraint$():{
    List<Constraint> sup = null;
}{
(   sup = parse_Cons$Constraint$() { return sup; } | 
    sup = parse_Empty$Constraint$() { return sup; } )
}
public Empty<Constraint> parse_Empty$Constraint$():{
}{

    { return new Empty<Constraint>(); }
}
public Cons<Constraint> parse_Cons$Constraint$():{
     Constraint first;
     List<Constraint> rest;
}{
    first = parse_Constraint()
    rest = parse_List$Constraint$()
    { return new Cons<Constraint>(first,rest); }
}
public List<Problem> parse_List$Problem$():{
    List<Problem> sup = null;
}{
(   sup = parse_Cons$Problem$() { return sup; } | 
    sup = parse_Empty$Problem$() { return sup; } )
}
public Empty<Problem> parse_Empty$Problem$():{
}{

    { return new Empty<Problem>(); }
}
public Cons<Problem> parse_Cons$Problem$():{
     Problem first;
     List<Problem> rest;
}{
    first = parse_Problem()
    rest = parse_List$Problem$()
    { return new Cons<Problem>(first,rest); }
}
SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" }
SKIP : { < "//" (~["\n","\r"])* ("\n"|"\r\n") >
       | < "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" > }
TOKEN: { < TRUE : "true" >
       | < FALSE : "false" > }
TOKEN: { < INT : ("+" | "-")? ( (["0"-"9"])+ 
                                  | ("0" ["x","X"]) (["0"-"9","a"-"f","A"-"F"])+ ) >
       | < DOUBLE : ("-")?(["0"-"9"])+ "." (["0"-"9"])+ (<EXPON>)?
                            | "." (["0"-"9"])+  (<EXPON>)? >
       | < #EXPON: ["e","E"] (["+","-"])? (["0"-"9"])+ > }
TOKEN: { < CHAR: "\'" 
              ( (~["\'","\\","\n","\r"]) | 
                ("\\" ( ["n","t","b","r","f","\\","\'","\""] |
                            ["0"-"7"] ( ["0"-"7"] )? |
                            ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) )
              "\'" >
       | < STRING :
              "\""
              (   (~["\"","\\","\n","\r"])
                | ("\\"
                    ( ["n","t","b","r","f","\\","'","\""]
                    | ["0"-"7"] ( ["0"-"7"] )?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                    )
                  )
              )*
              "\"" >
       | < TEXT : ( "{{" (~["}"])* ( "}" ~["}"] (~["}"])* )* "}}" ) >
       | < IDENT : ["a"-"z","A"-"Z","$","_"]
                   (["a"-"z","A"-"Z","0"-"9","_","$"])* > }

